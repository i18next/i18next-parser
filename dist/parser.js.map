{"version":3,"sources":["../src/parser.js"],"names":["lexers","hbs","handlebars","htm","html","mjs","js","ts","jsx","tsx","vue","lexersMap","HandlebarsLexer","HTMLLexer","JavascriptLexer","JsxLexer","VueLexer","Parser","options","content","filename","keys","extension","path","extname","substr","lexerConfig","lexerName","lexerOptions","lexer","Lexer","emit","Error","on","warning","concat","extract","EventEmitter"],"mappings":"gwBAAA;AACA;AACA;AACA;AACA;AACA;AACA,sE;;AAEA,IAAMA,MAAM,GAAG;AACbC,EAAAA,GAAG,EAAE,CAAC,iBAAD,CADQ;AAEbC,EAAAA,UAAU,EAAE,CAAC,iBAAD,CAFC;;AAIbC,EAAAA,GAAG,EAAE,CAAC,WAAD,CAJQ;AAKbC,EAAAA,IAAI,EAAE,CAAC,WAAD,CALO;;AAObC,EAAAA,GAAG,EAAE,CAAC,iBAAD,CAPQ;AAQbC,EAAAA,EAAE,EAAE,CAAC,iBAAD,CARS;AASbC,EAAAA,EAAE,EAAE,CAAC,iBAAD,CATS;AAUbC,EAAAA,GAAG,EAAE,CAAC,UAAD,CAVQ;AAWbC,EAAAA,GAAG,EAAE,CAAC,UAAD,CAXQ;;AAabC,EAAAA,GAAG,EAAE,CAAC,UAAD,CAbQ;;AAeb,aAAS,CAAC,iBAAD,CAfI,EAAf;;;AAkBA,IAAMC,SAAS,GAAG;AAChBC,EAAAA,eAAe,EAAfA,2BADgB;AAEhBC,EAAAA,SAAS,EAATA,qBAFgB;AAGhBC,EAAAA,eAAe,EAAfA,2BAHgB;AAIhBC,EAAAA,QAAQ,EAARA,oBAJgB;AAKhBC,EAAAA,QAAQ,EAARA,oBALgB,EAAlB,C;;;AAQqBC,M;AACnB,oBAA0B,eAAdC,OAAc,uEAAJ,EAAI;AACxB,8BAAMA,OAAN;AACA,UAAKA,OAAL,GAAeA,OAAf;AACA,UAAKlB,MAAL,mCAAmBA,MAAnB,GAA8BkB,OAAO,CAAClB,MAAtC,EAHwB;AAIzB,G;;AAED,mBAAMmB,OAAN,EAAeC,QAAf,EAAyB;AACvB,UAAIC,IAAI,GAAG,EAAX;AACA,UAAMC,SAAS,GAAGC,iBAAKC,OAAL,CAAaJ,QAAb,EAAuBK,MAAvB,CAA8B,CAA9B,CAAlB;AACA,UAAMzB,MAAM,GAAG,KAAKA,MAAL,CAAYsB,SAAZ,KAA0B,KAAKtB,MAAL,WAAzC,CAHuB;;AAKGA,MAAAA,MALH,aAKvB,oDAAkC,KAAvB0B,WAAuB;AAChC,cAAIC,SAAS,SAAb;AACA,cAAIC,YAAY,SAAhB;;AAEA;AACE,iBAAOF,WAAP,KAAuB,QAAvB;AACA,iBAAOA,WAAP,KAAuB,UAFzB;AAGE;AACAC,YAAAA,SAAS,GAAGD,WAAZ;AACAE,YAAAA,YAAY,GAAG,EAAf;AACD,WAND,MAMO;AACLD,YAAAA,SAAS,GAAGD,WAAW,CAACG,KAAxB;AACAD,YAAAA,YAAY,GAAGF,WAAf;AACD;;AAED,cAAII,KAAK,SAAT;AACA,cAAI,OAAOH,SAAP,KAAqB,UAAzB,EAAqC;AACnCG,YAAAA,KAAK,GAAGH,SAAR;AACD,WAFD,MAEO;AACL,gBAAI,CAAChB,SAAS,CAACgB,SAAD,CAAd,EAA2B;AACzB,mBAAKI,IAAL,CAAU,OAAV,EAAmB,IAAIC,KAAJ,kBAAoBL,SAApB,sBAAnB;AACD;;AAEDG,YAAAA,KAAK,GAAGnB,SAAS,CAACgB,SAAD,CAAjB;AACD;;AAED,cAAME,KAAK,GAAG,IAAIC,KAAJ,CAAUF,YAAV,CAAd;AACAC,UAAAA,KAAK,CAACI,EAAN,CAAS,SAAT,EAAoB,UAACC,OAAD,UAAa,MAAI,CAACH,IAAL,CAAU,SAAV,EAAqBG,OAArB,CAAb,EAApB;AACAb,UAAAA,IAAI,GAAGA,IAAI,CAACc,MAAL,CAAYN,KAAK,CAACO,OAAN,CAAcjB,OAAd,EAAuBC,QAAvB,CAAZ,CAAP;AACD,SAlCsB;;AAoCvB,aAAOC,IAAP;AACD,K,qBA5CiCgB,kB","sourcesContent":["import path from 'path'\nimport EventEmitter from 'events'\nimport HandlebarsLexer from './lexers/handlebars-lexer'\nimport HTMLLexer from './lexers/html-lexer'\nimport JavascriptLexer from './lexers/javascript-lexer'\nimport JsxLexer from './lexers/jsx-lexer'\nimport VueLexer from './lexers/vue-lexer'\n\nconst lexers = {\n  hbs: ['HandlebarsLexer'],\n  handlebars: ['HandlebarsLexer'],\n\n  htm: ['HTMLLexer'],\n  html: ['HTMLLexer'],\n\n  mjs: ['JavascriptLexer'],\n  js: ['JavascriptLexer'],\n  ts: ['JavascriptLexer'],\n  jsx: ['JsxLexer'],\n  tsx: ['JsxLexer'],\n\n  vue: ['VueLexer'],\n\n  default: ['JavascriptLexer'],\n}\n\nconst lexersMap = {\n  HandlebarsLexer,\n  HTMLLexer,\n  JavascriptLexer,\n  JsxLexer,\n  VueLexer,\n}\n\nexport default class Parser extends EventEmitter {\n  constructor(options = {}) {\n    super(options)\n    this.options = options\n    this.lexers = { ...lexers, ...options.lexers }\n  }\n\n  parse(content, filename) {\n    let keys = []\n    const extension = path.extname(filename).substr(1)\n    const lexers = this.lexers[extension] || this.lexers.default\n\n    for (const lexerConfig of lexers) {\n      let lexerName\n      let lexerOptions\n\n      if (\n        typeof lexerConfig === 'string' ||\n        typeof lexerConfig === 'function'\n      ) {\n        lexerName = lexerConfig\n        lexerOptions = {}\n      } else {\n        lexerName = lexerConfig.lexer\n        lexerOptions = lexerConfig\n      }\n\n      let Lexer\n      if (typeof lexerName === 'function') {\n        Lexer = lexerName\n      } else {\n        if (!lexersMap[lexerName]) {\n          this.emit('error', new Error(`Lexer '${lexerName}' does not exist`))\n        }\n\n        Lexer = lexersMap[lexerName]\n      }\n\n      const lexer = new Lexer(lexerOptions)\n      lexer.on('warning', (warning) => this.emit('warning', warning))\n      keys = keys.concat(lexer.extract(content, filename))\n    }\n\n    return keys\n  }\n}\n"],"file":"parser.js"}