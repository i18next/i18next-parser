{"version":3,"sources":["../../src/lexers/jsx-lexer.js"],"names":["JsxLexer","options","transSupportBasicHtmlNodes","transKeepBasicHtmlNodesFor","omitAttributes","attr","content","filename","keys","parseCommentNode","createCommentNodeParser","parseTree","node","entry","kind","ts","SyntaxKind","CallExpression","expressionExtractor","call","JsxElement","jsxExtractor","JsxSelfClosingElement","push","forEachChild","sourceFile","createSourceFile","ScriptTarget","Latest","setNamespaces","sourceText","tagNode","openingElement","getPropValue","tagName","attribute","attributes","properties","find","name","text","undefined","initializer","expression","getKey","key","defaultsProp","defaultValue","nodeToString","namespace","forEach","property","includes","children","parseChildren","elemsToString","map","child","index","type","useTagName","isBasic","elementName","childrenString","selfClosing","Error","join","JsxText","replace","element","escapedText","length","JsxExpression","StringLiteral","ObjectLiteralExpression","nonFormatProperties","filter","prop","emit","slice","pos","end","JavascriptLexer"],"mappings":"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","sourcesContent":["import JavascriptLexer from './javascript-lexer'\nimport * as ts from 'typescript'\n\nexport default class JsxLexer extends JavascriptLexer {\n  constructor(options = {}) {\n    super(options)\n\n    this.transSupportBasicHtmlNodes =\n      options.transSupportBasicHtmlNodes || false\n    this.transKeepBasicHtmlNodesFor = options.transKeepBasicHtmlNodesFor || [\n      'br',\n      'strong',\n      'i',\n      'p',\n    ]\n    this.omitAttributes = [this.attr, 'ns', 'defaults']\n  }\n\n  extract(content, filename = '__default.jsx') {\n    const keys = []\n\n    const parseCommentNode = this.createCommentNodeParser()\n\n    const parseTree = (node) => {\n      let entry\n\n      parseCommentNode(keys, node, content)\n\n      switch (node.kind) {\n        case ts.SyntaxKind.CallExpression:\n          entry = this.expressionExtractor.call(this, node)\n          break\n        case ts.SyntaxKind.JsxElement:\n          entry = this.jsxExtractor.call(this, node, content)\n          break\n        case ts.SyntaxKind.JsxSelfClosingElement:\n          entry = this.jsxExtractor.call(this, node, content)\n          break\n      }\n\n      if (entry) {\n        keys.push(entry)\n      }\n\n      node.forEachChild(parseTree)\n    }\n\n    const sourceFile = ts.createSourceFile(\n      filename,\n      content,\n      ts.ScriptTarget.Latest\n    )\n    parseTree(sourceFile)\n\n    return this.setNamespaces(keys)\n  }\n\n  jsxExtractor(node, sourceText) {\n    const tagNode = node.openingElement || node\n\n    const getPropValue = (node, tagName) => {\n      const attribute = node.attributes.properties.find(\n        (attr) => attr.name.text === tagName\n      )\n      if (!attribute) {\n        return undefined\n      }\n      return attribute.initializer.expression\n        ? attribute.initializer.expression.text\n        : attribute.initializer.text\n    }\n\n    const getKey = (node) => getPropValue(node, this.attr)\n\n    if (tagNode.tagName.text === 'Trans') {\n      const entry = {}\n      entry.key = getKey(tagNode)\n\n      const defaultsProp = getPropValue(tagNode, 'defaults')\n      const defaultValue =\n        defaultsProp || this.nodeToString.call(this, node, sourceText)\n\n      if (defaultValue !== '') {\n        entry.defaultValue = defaultValue\n\n        if (!entry.key) {\n          entry.key = entry.defaultValue\n        }\n      }\n\n      const namespace = getPropValue(tagNode, 'ns')\n      if (namespace) {\n        entry.namespace = namespace\n      }\n\n      tagNode.attributes.properties.forEach((property) => {\n        if (this.omitAttributes.includes(property.name.text)) {\n          return\n        }\n\n        if (property.initializer.expression) {\n          entry[\n            property.name.text\n          ] = `{${property.initializer.expression.text}}`\n        } else {\n          entry[property.name.text] = property.initializer.text\n        }\n      })\n\n      return entry.key ? entry : null\n    } else if (tagNode.tagName.text === 'Interpolate') {\n      const entry = {}\n      entry.key = getKey(tagNode)\n      return entry.key ? entry : null\n    }\n  }\n\n  nodeToString(node, sourceText) {\n    const children = this.parseChildren.call(this, node.children, sourceText)\n\n    const elemsToString = (children) =>\n      children\n        .map((child, index) => {\n          switch (child.type) {\n            case 'js':\n            case 'text':\n              return child.content\n            case 'tag':\n              const useTagName =\n                child.isBasic &&\n                this.transSupportBasicHtmlNodes &&\n                this.transKeepBasicHtmlNodesFor.includes(child.name)\n              const elementName = useTagName ? child.name : index\n              const childrenString = elemsToString(child.children)\n              return childrenString || !(useTagName && child.selfClosing)\n                ? `<${elementName}>${childrenString}</${elementName}>`\n                : `<${elementName} />`\n            default:\n              throw new Error('Unknown parsed content: ' + child.type)\n          }\n        })\n        .join('')\n\n    return elemsToString(children)\n  }\n\n  parseChildren(children = [], sourceText) {\n    return children\n      .map((child) => {\n        if (child.kind === ts.SyntaxKind.JsxText) {\n          return {\n            type: 'text',\n            content: child.text\n              .replace(/(^(\\n|\\r)\\s*)|((\\n|\\r)\\s*$)/g, '')\n              .replace(/(\\n|\\r)\\s*/g, ' '),\n          }\n        } else if (\n          child.kind === ts.SyntaxKind.JsxElement ||\n          child.kind === ts.SyntaxKind.JsxSelfClosingElement\n        ) {\n          const element = child.openingElement || child\n          const name = element.tagName.escapedText\n          const isBasic = !element.attributes.properties.length\n          return {\n            type: 'tag',\n            children: this.parseChildren(child.children, sourceText),\n            name,\n            isBasic,\n            selfClosing: child.kind === ts.SyntaxKind.JsxSelfClosingElement,\n          }\n        } else if (child.kind === ts.SyntaxKind.JsxExpression) {\n          // strip empty expressions\n          if (!child.expression) {\n            return {\n              type: 'text',\n              content: '',\n            }\n          } else if (child.expression.kind === ts.SyntaxKind.StringLiteral) {\n            return {\n              type: 'text',\n              content: child.expression.text,\n            }\n          }\n\n          // strip properties from ObjectExpressions\n          // annoying (and who knows how many other exceptions we'll need to write) but necessary\n          else if (\n            child.expression.kind === ts.SyntaxKind.ObjectLiteralExpression\n          ) {\n            // i18next-react only accepts two props, any random single prop, and a format prop\n            // for our purposes, format prop is always ignored\n\n            let nonFormatProperties = child.expression.properties.filter(\n              (prop) => prop.name.text !== 'format'\n            )\n\n            // more than one property throw a warning in i18next-react, but still works as a key\n            if (nonFormatProperties.length > 1) {\n              this.emit(\n                'warning',\n                `The passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.`\n              )\n\n              return {\n                type: 'text',\n                content: '',\n              }\n            }\n\n            return {\n              type: 'js',\n              content: `{{${nonFormatProperties[0].name.text}}}`,\n            }\n          }\n\n          // slice on the expression so that we ignore comments around it\n          return {\n            type: 'js',\n            content: `{${sourceText.slice(\n              child.expression.pos,\n              child.expression.end\n            )}}`,\n          }\n        } else {\n          throw new Error('Unknown ast element when parsing jsx: ' + child.kind)\n        }\n      })\n      .filter((child) => child.type !== 'text' || child.content)\n  }\n}\n"],"file":"jsx-lexer.js"}