{"version":3,"sources":["../../src/lexers/html-lexer.js"],"names":["HTMLLexer","options","attr","optionAttr","content","that","$","cheerio","load","each","index","node","$node","keys","attribs","split","JSON","parse","key","replace","text","push","BaseLexer"],"mappings":"gwBAAA;AACA,0D;;AAEqBA,S;AACnB,uBAA0B,eAAdC,OAAc,uEAAJ,EAAI;AACxB,8BAAMA,OAAN;;AAEA,UAAKC,IAAL,GAAYD,OAAO,CAACC,IAAR,IAAgB,WAA5B;AACA,UAAKC,UAAL,GAAkBF,OAAO,CAACE,UAAR,IAAsB,mBAAxC,CAJwB;AAKzB,G;;AAED,qBAAQC,OAAR,EAAiB;AACf,UAAMC,IAAI,GAAG,IAAb;AACA,UAAMC,CAAC,GAAGC,oBAAQC,IAAR,CAAaJ,OAAb,CAAV;AACAE,MAAAA,CAAC,YAAKD,IAAI,CAACH,IAAV,OAAD,CAAoBO,IAApB,CAAyB,UAACC,KAAD,EAAQC,IAAR,EAAiB;AACxC,YAAMC,KAAK,GAAGL,oBAAQC,IAAR,CAAaG,IAAb,CAAd;;AAEA;AACA,YAAME,IAAI,GAAGF,IAAI,CAACG,OAAL,CAAaT,IAAI,CAACH,IAAlB,EAAwBa,KAAxB,CAA8B,GAA9B,CAAb;AACA,YAAId,OAAO,GAAGU,IAAI,CAACG,OAAL,CAAaT,IAAI,CAACF,UAAlB,CAAd;;AAEA,YAAIF,OAAJ,EAAa;AACX,cAAI;AACFA,YAAAA,OAAO,GAAGe,IAAI,CAACC,KAAL,CAAWhB,OAAX,CAAV;AACD,WAFD,SAEU;AACT;AACF,SAZuC;;AAcxBY,QAAAA,IAdwB,aAcxC,oDAAsB,KAAbK,GAAa;AACpB;AACAA,YAAAA,GAAG,GAAGA,GAAG,CAACC,OAAJ,CAAY,qBAAZ,EAAmC,EAAnC,CAAN;;AAEA;AACAD,YAAAA,GAAG,GAAGA,GAAG,IAAIN,KAAK,CAACQ,IAAN,EAAb;;AAEA,gBAAIF,GAAJ,EAAS;AACP,cAAA,MAAI,CAACL,IAAL,CAAUQ,IAAV,iCAAoBpB,OAApB,SAA6BiB,GAAG,EAAHA,GAA7B;AACD;AACF,WAxBuC;AAyBzC,OAzBD;;AA2BA,aAAO,KAAKL,IAAZ;AACD,K,wBAvCoCS,qB","sourcesContent":["import BaseLexer from './base-lexer'\nimport cheerio from 'cheerio'\n\nexport default class HTMLLexer extends BaseLexer {\n  constructor(options = {}) {\n    super(options)\n\n    this.attr = options.attr || 'data-i18n'\n    this.optionAttr = options.optionAttr || 'data-i18n-options'\n  }\n\n  extract(content) {\n    const that = this\n    const $ = cheerio.load(content)\n    $(`[${that.attr}]`).each((index, node) => {\n      const $node = cheerio.load(node)\n\n      // the attribute can hold multiple keys\n      const keys = node.attribs[that.attr].split(';')\n      let options = node.attribs[that.optionAttr]\n\n      if (options) {\n        try {\n          options = JSON.parse(options)\n        } finally {\n        }\n      }\n\n      for (let key of keys) {\n        // remove any leading [] in the key\n        key = key.replace(/^\\[[a-zA-Z0-9_-]*\\]/, '')\n\n        // if empty grab innerHTML from regex\n        key = key || $node.text()\n\n        if (key) {\n          this.keys.push({ ...options, key })\n        }\n      }\n    })\n\n    return this.keys\n  }\n}\n"],"file":"html-lexer.js"}