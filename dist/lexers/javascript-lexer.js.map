{"version":3,"sources":["../../src/lexers/javascript-lexer.js"],"names":["JavascriptLexer","options","callPattern","functionPattern","functions","attr","visitedComments","Set","keys","node","content","ts","forEachLeadingCommentRange","getFullStart","pos","end","kind","commentId","SyntaxKind","MultiLineCommentTrivia","SingleLineCommentTrivia","has","add","text","slice","commentKeys","commentExtractor","call","push","defaultNamespace","map","entry","namespace","filename","parseCommentNode","createCommentNodeParser","parseTree","CallExpression","expressionExtractor","forEachChild","sourceFile","createSourceFile","ScriptTarget","Latest","setNamespaces","expression","escapedText","arguments","length","elements","isTranslationFunction","includes","name","keyArgument","shift","StringLiteral","NoSubstitutionTemplateLiteral","key","BinaryExpression","concatenatedString","concatenateString","emit","Identifier","optionsArgument","defaultValue","ObjectLiteralExpression","properties","p","PropertyAssignment","initializer","SpreadAssignment","ns","commentText","regexp","RegExp","expressions","match","forEach","expressionKeys","extract","binaryExpression","string","operatorToken","PlusToken","left","right","BaseLexer"],"mappings":"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","sourcesContent":["import BaseLexer from './base-lexer'\nimport * as ts from 'typescript'\n\nexport default class JavascriptLexer extends BaseLexer {\n  constructor(options = {}) {\n    super(options)\n\n    this.callPattern = '(?<=^|\\\\s|\\\\.)' + this.functionPattern() + '\\\\(.*\\\\)'\n    this.functions = options.functions || ['t']\n    this.attr = options.attr || 'i18nKey'\n  }\n\n  createCommentNodeParser() {\n    const visitedComments = new Set()\n\n    return (keys, node, content) => {\n      ts.forEachLeadingCommentRange(\n        content,\n        node.getFullStart(),\n        (pos, end, kind) => {\n          const commentId = `${pos}_${end}`\n          if (\n            (kind === ts.SyntaxKind.MultiLineCommentTrivia ||\n              kind === ts.SyntaxKind.SingleLineCommentTrivia) &&\n            !visitedComments.has(commentId)\n          ) {\n            visitedComments.add(commentId)\n            const text = content.slice(pos, end)\n            const commentKeys = this.commentExtractor.call(this, text)\n            if (commentKeys) {\n              keys.push(...commentKeys)\n            }\n          }\n        }\n      )\n    }\n  }\n\n  setNamespaces(keys) {\n    if (this.defaultNamespace) {\n      return keys.map((entry) => ({\n        ...entry,\n        namespace: entry.namespace || this.defaultNamespace,\n      }))\n    }\n\n    return keys\n  }\n\n  extract(content, filename = '__default.js') {\n    const keys = []\n\n    const parseCommentNode = this.createCommentNodeParser()\n\n    const parseTree = (node) => {\n      let entry\n\n      parseCommentNode(keys, node, content)\n\n      if (node.kind === ts.SyntaxKind.CallExpression) {\n        entry = this.expressionExtractor.call(this, node)\n      }\n\n      if (entry) {\n        keys.push(entry)\n      }\n\n      node.forEachChild(parseTree)\n    }\n\n    const sourceFile = ts.createSourceFile(\n      filename,\n      content,\n      ts.ScriptTarget.Latest\n    )\n    parseTree(sourceFile)\n\n    return this.setNamespaces(keys)\n  }\n\n  expressionExtractor(node) {\n    const entry = {}\n\n    if (\n      node.expression.escapedText === 'useTranslation' &&\n      node.arguments.length\n    ) {\n      this.defaultNamespace = node.arguments[0].text\n    }\n\n    if (\n      node.expression.escapedText === 'withTranslation' &&\n      node.arguments.length\n    ) {\n      const { text, elements } = node.arguments[0]\n      if (text) {\n        this.defaultNamespace = text\n      } else if (elements && elements.length) {\n        this.defaultNamespace = elements[0].text\n      }\n    }\n\n    const isTranslationFunction =\n      (node.expression.text && this.functions.includes(node.expression.text)) ||\n      (node.expression.name &&\n        this.functions.includes(node.expression.name.text))\n\n    if (isTranslationFunction) {\n      const keyArgument = node.arguments.shift()\n\n      if (!keyArgument) {\n        return null\n      }\n\n      if (\n        keyArgument.kind === ts.SyntaxKind.StringLiteral ||\n        keyArgument.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral\n      ) {\n        entry.key = keyArgument.text\n      } else if (keyArgument.kind === ts.SyntaxKind.BinaryExpression) {\n        const concatenatedString = this.concatenateString(keyArgument)\n        if (!concatenatedString) {\n          this.emit(\n            'warning',\n            `Key is not a string literal: ${keyArgument.text}`\n          )\n          return null\n        }\n        entry.key = concatenatedString\n      } else {\n        this.emit(\n          'warning',\n          keyArgument.kind === ts.SyntaxKind.Identifier\n            ? `Key is not a string literal: ${keyArgument.text}`\n            : 'Key is not a string literal'\n        )\n        return null\n      }\n\n      let optionsArgument = node.arguments.shift()\n\n      // Second argument could be a string default value\n      if (\n        optionsArgument &&\n        optionsArgument.kind === ts.SyntaxKind.StringLiteral\n      ) {\n        entry.defaultValue = optionsArgument.text\n        optionsArgument = node.arguments.shift()\n      }\n\n      if (\n        optionsArgument &&\n        optionsArgument.kind === ts.SyntaxKind.ObjectLiteralExpression\n      ) {\n        for (const p of optionsArgument.properties) {\n          if (p.kind === ts.SyntaxKind.PropertyAssignment) {\n            entry[p.name.text] = (p.initializer && p.initializer.text) || ''\n          }\n          else if (p.kind === ts.SyntaxKind.SpreadAssignment) {\n            this.emit(\n              'warning',\n              `Options argument is a spread operator : ${p.expression.text}`\n            )\n          }\n        }\n      }\n\n      if (entry.ns) {\n        if (typeof entry.ns === 'string') {\n          entry.namespace = entry.ns\n        } else if (typeof entry.ns === 'object' && entry.ns.length) {\n          entry.namespace = entry.ns[0]\n        }\n      }\n\n      return entry\n    }\n\n    return null\n  }\n\n  commentExtractor(commentText) {\n    const regexp = new RegExp(this.callPattern, 'g')\n    const expressions = commentText.match(regexp)\n\n    if (!expressions) {\n      return null\n    }\n\n    const keys = []\n    expressions.forEach((expression) => {\n      const expressionKeys = this.extract(expression)\n      if (expressionKeys) {\n        keys.push(...expressionKeys)\n      }\n    })\n    return keys\n  }\n\n  concatenateString(binaryExpression, string = '') {\n    if (binaryExpression.operatorToken.kind !== ts.SyntaxKind.PlusToken) {\n      return\n    }\n\n    if (binaryExpression.left.kind === ts.SyntaxKind.BinaryExpression) {\n      string += this.concatenateString(binaryExpression.left, string)\n    } else if (binaryExpression.left.kind === ts.SyntaxKind.StringLiteral) {\n      string += binaryExpression.left.text\n    } else {\n      return\n    }\n\n    if (binaryExpression.right.kind === ts.SyntaxKind.BinaryExpression) {\n      string += this.concatenateString(binaryExpression.right, string)\n    } else if (binaryExpression.right.kind === ts.SyntaxKind.StringLiteral) {\n      string += binaryExpression.right.text\n    } else {\n      return\n    }\n\n    return string\n  }\n}\n"],"file":"javascript-lexer.js"}