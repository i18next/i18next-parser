{"version":3,"sources":["../src/helpers.js"],"names":["dotPathToHash","entry","target","options","conflict","duplicate","path","keyWithNamespace","suffix","pluralSeparator","separator","key","substring","indexOf","length","namespace","defaultValue","value","locale","skipDefaultValues","useKeysAsDefaultValue","newValue","endsWith","slice","segments","split","inner","i","segment","undefined","lastSegment","oldValue","customValueTemplate","entries","Object","forEach","valueEntry","replace","mergeHashes","source","keepRemoved","old","mergeCount","pullCount","oldCount","hasNestedEntries","Array","isArray","nested","keys","pluralRegex","pluralMatch","test","singularKey","contextRegex","contextMatch","rawKey","transferValues","sourceValue","targetValue"],"mappings":"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","sourcesContent":["/**\n * Take an entry for the Parser and turn it into a hash,\n * turning the key path 'foo.bar' into an hash {foo: {bar: \"\"}}\n * The generated hash can be merged with an optional `target`.\n * @returns An `{ target, duplicate, conflict }` object. `target` is the hash\n * that was passed as an argument or a new hash if none was passed. `duplicate`\n * indicates whether the entry already existed in the `target` hash. `conflict`\n * is `\"key\"` if a parent of the key was already mapped to a string (e.g. when\n * merging entry {one: {two: \"bla\"}} with target {one: \"bla\"}) or the key was\n * already mapped to a map (e.g. when merging entry {one: \"bla\"} with target\n * {one: {two: \"bla\"}}), `\"value\"` if the same key already exists swith a\n * different value, or `false`.\n */\nfunction dotPathToHash(entry, target = {}, options = {}) {\n  let conflict = false\n  let duplicate = false\n  let path = entry.keyWithNamespace\n  if (options.suffix || options.suffix === 0) {\n    path += `${options.pluralSeparator}${options.suffix}`\n  }\n\n  const separator = options.separator || '.'\n\n  const key = entry.keyWithNamespace.substring(\n    entry.keyWithNamespace.indexOf(separator) + separator.length,\n    entry.keyWithNamespace.length\n  )\n\n  // There is no key to process so we return an empty object\n  if (!key) {\n    target[entry.namespace] = {}\n    return { target, duplicate, conflict }\n  }\n\n  const defaultValue =\n    typeof options.value === 'function'\n      ? options.value(options.locale, entry.namespace, key)\n      : options.value\n\n  const skipDefaultValues =\n    typeof options.skipDefaultValues === 'function'\n      ? options.skipDefaultValues(options.locale, entry.namespace)\n      : options.skipDefaultValues\n\n  const useKeysAsDefaultValue =\n    typeof options.useKeysAsDefaultValue === 'function'\n      ? options.useKeysAsDefaultValue(options.locale, entry.namespace)\n      : options.useKeysAsDefaultValue\n\n  let newValue =\n    entry[`defaultValue_${options.suffix}`] ||\n    entry.defaultValue ||\n    defaultValue ||\n    ''\n\n  if (skipDefaultValues) {\n    newValue = ''\n  }\n\n  if (useKeysAsDefaultValue) {\n    newValue = key\n  }\n\n  if (path.endsWith(separator)) {\n    path = path.slice(0, -separator.length)\n  }\n\n  const segments = path.split(separator)\n  let inner = target\n  for (let i = 0; i < segments.length - 1; i += 1) {\n    const segment = segments[i]\n    if (segment) {\n      if (typeof inner[segment] === 'string') {\n        conflict = 'key'\n      }\n      if (inner[segment] === undefined || conflict) {\n        inner[segment] = {}\n      }\n      inner = inner[segment]\n    }\n  }\n\n  const lastSegment = segments[segments.length - 1]\n  const oldValue = inner[lastSegment]\n  if (oldValue !== undefined && oldValue !== newValue) {\n    conflict = typeof oldValue !== typeof newValue ? 'key' : 'value'\n  }\n  duplicate = oldValue !== undefined || conflict !== false\n\n  if (options.customValueTemplate) {\n    inner[lastSegment] = {}\n\n    const entries = Object.entries(options.customValueTemplate)\n    entries.forEach((valueEntry) => {\n      if (valueEntry[1] === '${defaultValue}') {\n        inner[lastSegment][valueEntry[0]] = newValue\n      } else {\n        inner[lastSegment][valueEntry[0]] =\n          entry[valueEntry[1].replace(/\\${(\\w+)}/, '$1')] || ''\n      }\n    })\n  } else {\n    inner[lastSegment] = newValue\n  }\n\n  return { target, duplicate, conflict }\n}\n\n/**\n * Takes a `source` hash and makes sure its value\n * is pasted in the `target` hash, if the target\n * hash has the corresponding key (or if `keepRemoved` is true).\n * @returns An `{ old, new, mergeCount, pullCount, oldCount }` object.\n * `old` is a hash of values that have not been merged into `target`.\n * `new` is `target`. `mergeCount` is the number of keys merged into\n * `new`, `pullCount` is the number of context and plural keys added to\n * `new` and `oldCount` is the number of keys that were either added to `old` or\n * `new` (if `keepRemoved` is true and `target` didn't have the corresponding\n * key).\n */\nfunction mergeHashes(source, target, keepRemoved = false) {\n  let old = {}\n  let mergeCount = 0\n  let pullCount = 0\n  let oldCount = 0\n  for (const key in source) {\n    const hasNestedEntries =\n      typeof target[key] === 'object' && !Array.isArray(target[key])\n\n    if (hasNestedEntries) {\n      const nested = mergeHashes(source[key], target[key], keepRemoved)\n      mergeCount += nested.mergeCount\n      pullCount += nested.pullCount\n      if (Object.keys(nested.old).length) {\n        old[key] = nested.old\n        oldCount += nested.oldCount\n      }\n    } else {\n      if (target[key] !== undefined) {\n        if (typeof source[key] === 'string' || Array.isArray(source[key])) {\n          target[key] = source[key]\n          mergeCount += 1\n        } else {\n          old[key] = source[key]\n          oldCount += 1\n        }\n      } else {\n        // support for plural in keys\n        const pluralRegex = /(_plural)|(_\\d+)$/\n        const pluralMatch = pluralRegex.test(key)\n        const singularKey = key.replace(pluralRegex, '')\n\n        // support for context in keys\n        const contextRegex = /_([^_]+)?$/\n        const contextMatch = contextRegex.test(singularKey)\n        const rawKey = singularKey.replace(contextRegex, '')\n\n        if (\n          (contextMatch && target[rawKey] !== undefined) ||\n          (pluralMatch && target[singularKey] !== undefined)\n        ) {\n          target[key] = source[key]\n          pullCount += 1\n        } else {\n          if (keepRemoved) {\n            target[key] = source[key]\n          } else {\n            old[key] = source[key]\n          }\n          oldCount += 1\n        }\n      }\n    }\n  }\n\n  return { old, new: target, mergeCount, pullCount, oldCount }\n}\n\n/**\n * Merge `source` into `target` by merging nested dictionaries.\n */\nfunction transferValues(source, target) {\n  for (const key in source) {\n    const sourceValue = source[key]\n    const targetValue = target[key]\n    if (\n      typeof sourceValue === 'object' &&\n      typeof targetValue === 'object' &&\n      !Array.isArray(sourceValue)\n    ) {\n      transferValues(sourceValue, targetValue)\n    } else {\n      target[key] = sourceValue\n    }\n  }\n}\n\nexport { dotPathToHash, mergeHashes, transferValues }\n"],"file":"helpers.js"}